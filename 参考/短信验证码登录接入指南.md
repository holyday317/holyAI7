# 短信验证码登录接入指南

## 一、短信服务商对比

### 主流短信服务商

| 服务商 | 价格（单条） | 稳定性 | 文档质量 | 推荐度 |
|-------|------------|-------|---------|-------|
| **阿里云短信** | ¥0.045-0.055 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **腾讯云短信** | ¥0.045-0.055 | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **容联云通讯** | ¥0.040-0.050 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **网易云信** | ¥0.040-0.050 | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ |
| **七牛云短信** | ¥0.045-0.055 | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **又拍云短信** | ¥0.040-0.050 | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |

### 推荐方案

**首选**：阿里云短信或腾讯云短信
- 稳定性最高，到达率>99%
- 文档完善，SDK支持好
- 价格透明，无隐形消费
- 国内用户使用习惯好

---

## 二、开通条件（以阿里云为例）

### 1. 账户要求
- ✅ 阿里云账号（个人或企业均可）
- ✅ 实名认证（个人或企业认证）
- ✅ 绑定手机号和邮箱

### 2. 费用说明
- **免费额度**：新用户赠送100条短信
- **充值门槛**：最低充值¥100
- **价格**：国内短信¥0.045/条
- **计费**：按实际发送量计费，失败不收费

### 3. 审核要求
- **短信签名**：需要审核，通常1-2小时
- **短信模板**：需要审核，通常1-2小时
- **特殊业务**：需要提供相关资质证明

### 4. 限制说明
- **发送频率**：同一手机号1分钟1条，1小时5条，1天10条
- **敏感词**：不能包含敏感词（赌博、色情等）
- **营销短信**：需要额外申请营销资质

---

## 三、接入步骤（阿里云示例）

### 步骤1：开通阿里云短信服务

1. 访问 [https://dysms.console.aliyun.com](https://dysms.console.aliyun.com)
2. 点击"立即开通"
3. 完成实名认证
4. 充值余额（最低¥100）

### 步骤2：创建短信签名

1. 进入"国内消息" > "签名管理"
2. 点击"添加签名"
3. 填写签名信息：
   ```
   签名名称：holy7
   适用场景：验证码
   签名来源：已备案网站/已上线App
   签名来源证明：上传相关证明文件
   ```
4. 提交审核（1-2小时）

### 步骤3：创建短信模板

1. 进入"国内消息" > "模板管理"
2. 点击"添加模板"
3. 填写模板信息：
   ```
   模板类型：验证码
   模板名称：登录验证码
   模板内容：您的验证码是${code}，5分钟内有效，请勿泄露给他人。
   适用场景：验证码
   申请说明：用于用户登录验证
   ```
4. 提交审核（1-2小时）

### 步骤4：获取AccessKey

1. 进入 [https://ram.console.aliyun.com/manage/ak](https://ram.console.aliyun.com/manage/ak)
2. 创建AccessKey
3. 保存AccessKey ID和AccessKey Secret（只显示一次）

---

## 四、后端实现

### 1. 安装依赖

```bash
cd holy7-express
npm install @alicloud/dysmsapi20170525 @alicloud/openapi-client crypto-js
```

### 2. 配置环境变量

在 `.env.dev` 中添加：

```env
# 阿里云短信配置
ALIYUN_ACCESS_KEY_ID=你的AccessKeyID
ALIYUN_ACCESS_KEY_SECRET=你的AccessKeySecret
ALIYUN_SIGN_NAME=holy7
ALIYUN_TEMPLATE_CODE=你的模板CODE
SMS_CODE_EXPIRE_TIME=300 # 验证码过期时间（秒）
SMS_CODE_LENGTH=6 # 验证码长度
```

### 3. 创建短信服务

创建 `services/smsService.js`：

```javascript
const Dysmsapi = require('@alicloud/dysmsapi20170525');
const OpenApi = require('@alicloud/openapi-client');
const CryptoJS = require('crypto-js');

class SMSService {
  constructor() {
    const config = new OpenApi.Config({
      accessKeyId: process.env.ALIYUN_ACCESS_KEY_ID,
      accessKeySecret: process.env.ALIYUN_ACCESS_KEY_SECRET,
    });
    config.endpoint = 'dysmsapi.aliyuncs.com';
    this.client = new Dysmsapi.default(config);
  }

  /**
   * 生成验证码
   */
  static generateCode(length = 6) {
    const min = Math.pow(10, length - 1);
    const max = Math.pow(10, length) - 1;
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  /**
   * 发送验证码
   */
  async sendCode(phone, code) {
    try {
      const request = new Dysmsapi.SendSmsRequest({
        phoneNumbers: phone,
        signName: process.env.ALIYUN_SIGN_NAME,
        templateCode: process.env.ALIYUN_TEMPLATE_CODE,
        templateParam: JSON.stringify({ code }),
      });

      const response = await this.client.sendSms(request);

      if (response.body.code === 'OK') {
        return {
          success: true,
          requestId: response.body.requestId,
          bizId: response.body.bizId,
        };
      } else {
        return {
          success: false,
          message: response.body.message,
        };
      }
    } catch (error) {
      console.error('发送短信失败:', error);
      return {
        success: false,
        message: error.message,
      };
    }
  }

  /**
   * 验证手机号格式
   */
  static validatePhone(phone) {
    const phoneReg = /^1[3-9]\d{9}$/;
    return phoneReg.test(phone);
  }
}

module.exports = SMSService;
```

### 4. 创建验证码存储服务

创建 `services/verifyCodeService.js`：

```javascript
class VerifyCodeService {
  constructor() {
    this.codes = new Map(); // 生产环境建议使用Redis
  }

  /**
   * 存储验证码
   */
  setCode(phone, code, expireTime = 300) {
    const expireAt = Date.now() + expireTime * 1000;
    this.codes.set(phone, {
      code,
      expireAt,
      count: 1, // 发送次数
    });
  }

  /**
   * 获取验证码
   */
  getCode(phone) {
    return this.codes.get(phone);
  }

  /**
   * 验证验证码
   */
  verifyCode(phone, code) {
    const record = this.codes.get(phone);
    
    if (!record) {
      return {
        valid: false,
        message: '验证码不存在或已过期',
      };
    }

    if (Date.now() > record.expireAt) {
      this.codes.delete(phone);
      return {
        valid: false,
        message: '验证码已过期',
      };
    }

    if (record.code !== code) {
      return {
        valid: false,
        message: '验证码错误',
      };
    }

    // 验证成功，删除记录
    this.codes.delete(phone);
    return {
      valid: true,
      message: '验证成功',
    };
  }

  /**
   * 检查是否可以发送
   */
  canSend(phone, interval = 60, maxCount = 5, maxTime = 3600) {
    const record = this.codes.get(phone);
    const now = Date.now();

    if (!record) {
      return {
        canSend: true,
      };
    }

    // 检查发送间隔
    const lastSendTime = record.expireAt - (parseInt(process.env.SMS_CODE_EXPIRE_TIME) || 300) * 1000;
    if (now - lastSendTime < interval * 1000) {
      return {
        canSend: false,
        message: `请${Math.ceil((interval * 1000 - (now - lastSendTime)) / 1000)}秒后再试`,
      };
    }

    // 检查发送次数
    const oneHourAgo = now - maxTime * 1000;
    if (record.count >= maxCount && record.expireAt > oneHourAgo) {
      return {
        canSend: false,
        message: '发送次数过多，请1小时后再试',
      };
    }

    return {
      canSend: true,
    };
  }

  /**
   * 增加发送次数
   */
  incrementCount(phone) {
    const record = this.codes.get(phone);
    if (record) {
      record.count++;
    }
  }

  /**
   * 清理过期验证码
   */
  cleanExpired() {
    const now = Date.now();
    for (const [phone, record] of this.codes.entries()) {
      if (now > record.expireAt) {
        this.codes.delete(phone);
      }
    }
  }

  /**
   * 定期清理（建议每分钟执行一次）
   */
  startCleanTask() {
    setInterval(() => {
      this.cleanExpired();
    }, 60000);
  }
}

// 创建单例实例
const verifyCodeService = new VerifyCodeService();

module.exports = verifyCodeService;
```

### 5. 创建用户模型

创建 `models/User.js`：

```javascript
const db = require('../config/database');

class User {
  /**
   * 根据手机号查找用户
   */
  static findByPhone(phone) {
    const users = db.findAll('users');
    return users.find(user => user.phone === phone);
  }

  /**
   * 创建用户
   */
  static create(data) {
    const { phone, nickname, avatar } = data;
    return db.insert('users', {
      phone,
      nickname: nickname || phone,
      avatar: avatar || '',
    });
  }

  /**
   * 更新用户信息
   */
  static update(id, data) {
    return db.update('users', id, data);
  }

  /**
   * 生成JWT Token
   */
  static generateToken(user) {
    const jwt = require('jsonwebtoken');
    return jwt.sign(
      { 
        userId: user.id,
        phone: user.phone,
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '7d' }
    );
  }
}

module.exports = User;
```

### 6. 创建认证路由

创建 `routes/authRoutes.js`：

```javascript
const express = require('express');
const router = express.Router();
const SMSService = require('../services/smsService');
const verifyCodeService = require('../services/verifyCodeService');
const User = require('../models/User');
const rateLimit = require('express-rate-limit');

// 启动验证码清理任务
verifyCodeService.startCleanTask();

// 发送验证码限流
const sendCodeLimiter = rateLimit({
  windowMs: 60 * 1000, // 1分钟
  max: 1, // 最多1次
  message: { success: false, message: '发送过于频繁，请稍后再试' },
});

// 登录限流
const loginLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1小时
  max: 10, // 最多10次
  message: { success: false, message: '登录次数过多，请稍后再试' },
});

/**
 * 发送验证码
 */
router.post('/send-code', sendCodeLimiter, async (req, res) => {
  try {
    const { phone } = req.body;

    // 验证手机号
    if (!SMSService.validatePhone(phone)) {
      return res.status(400).json({
        success: false,
        message: '手机号格式不正确',
      });
    }

    // 检查是否可以发送
    const canSend = verifyCodeService.canSend(phone);
    if (!canSend.canSend) {
      return res.status(429).json({
        success: false,
        message: canSend.message,
      });
    }

    // 生成验证码
    const code = SMSService.generateCode(
      parseInt(process.env.SMS_CODE_LENGTH) || 6
    );

    // 发送验证码
    const smsService = new SMSService();
    const result = await smsService.sendCode(phone, code);

    if (!result.success) {
      return res.status(500).json({
        success: false,
        message: '发送验证码失败',
        error: result.message,
      });
    }

    // 存储验证码
    verifyCodeService.setCode(
      phone,
      code,
      parseInt(process.env.SMS_CODE_EXPIRE_TIME) || 300
    );

    // 增加发送次数
    verifyCodeService.incrementCount(phone);

    res.json({
      success: true,
      message: '验证码发送成功',
      data: {
        expireTime: parseInt(process.env.SMS_CODE_EXPIRE_TIME) || 300,
      },
    });
  } catch (error) {
    console.error('发送验证码错误:', error);
    res.status(500).json({
      success: false,
      message: '服务器错误',
    });
  }
});

/**
 * 验证码登录
 */
router.post('/login', loginLimiter, async (req, res) => {
  try {
    const { phone, code } = req.body;

    // 验证手机号
    if (!SMSService.validatePhone(phone)) {
      return res.status(400).json({
        success: false,
        message: '手机号格式不正确',
      });
    }

    // 验证验证码
    const verifyResult = verifyCodeService.verifyCode(phone, code);
    if (!verifyResult.valid) {
      return res.status(400).json({
        success: false,
        message: verifyResult.message,
      });
    }

    // 查找或创建用户
    let user = User.findByPhone(phone);
    if (!user) {
      user = User.create({
        phone,
        nickname: `用户${phone.slice(-4)}`,
      });
    }

    // 更新最后登录时间
    User.update(user.id, {
      lastLoginAt: new Date().toISOString(),
    });

    // 生成Token
    const token = User.generateToken(user);

    res.json({
      success: true,
      message: '登录成功',
      data: {
        token,
        user: {
          id: user.id,
          phone: user.phone,
          nickname: user.nickname,
          avatar: user.avatar,
        },
      },
    });
  } catch (error) {
    console.error('登录错误:', error);
    res.status(500).json({
      success: false,
      message: '服务器错误',
    });
  }
});

/**
 * 获取用户信息
 */
router.get('/user', async (req, res) => {
  try {
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        success: false,
        message: '未提供Token',
      });
    }

    const jwt = require('jsonwebtoken');
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');
    
    const user = User.findById(decoded.userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: '用户不存在',
      });
    }

    res.json({
      success: true,
      data: {
        id: user.id,
        phone: user.phone,
        nickname: user.nickname,
        avatar: user.avatar,
      },
    });
  } catch (error) {
    console.error('获取用户信息错误:', error);
    res.status(401).json({
      success: false,
      message: 'Token无效或已过期',
    });
  }
});

module.exports = router;
```

### 7. 安装依赖包

```bash
npm install express-rate-limit jsonwebtoken
```

### 8. 在主服务器中注册路由

修改 `server.js`：

```javascript
const authRoutes = require('./routes/authRoutes');

// 注册认证路由
app.use('/api/auth', authRoutes);
```

---

## 五、前端实现

### 1. 创建认证API服务

创建 `src/api/auth.js`：

```javascript
import request from '@/utils/request';

/**
 * 发送验证码
 */
export const sendCode = (phone) => {
  return request({
    url: '/auth/send-code',
    method: 'post',
    data: { phone },
  });
};

/**
 * 验证码登录
 */
export const loginByCode = (phone, code) => {
  return request({
    url: '/auth/login',
    method: 'post',
    data: { phone, code },
  });
};

/**
 * 获取用户信息
 */
export const getUserInfo = () => {
  return request({
    url: '/auth/user',
    method: 'get',
  });
};
```

### 2. 创建登录页面组件

创建 `src/components/LoginDialog.vue`：

```vue
<template>
  <el-dialog
    v-model="dialogVisible"
    title="手机号登录"
    width="400px"
    :close-on-click-modal="false"
  >
    <el-form :model="form" :rules="rules" ref="formRef">
      <el-form-item prop="phone">
        <el-input
          v-model="form.phone"
          placeholder="请输入手机号"
          maxlength="11"
          clearable
        >
          <template #prefix>
            <el-icon><Phone /></el-icon>
          </template>
        </el-input>
      </el-form-item>

      <el-form-item prop="code">
        <el-input
          v-model="form.code"
          placeholder="请输入验证码"
          maxlength="6"
          clearable
        >
          <template #prefix>
            <el-icon><Key /></el-icon>
          </template>
          <template #append>
            <el-button
              type="primary"
              :disabled="sending || countdown > 0"
              :loading="sending"
              @click="handleSendCode"
            >
              {{ countdown > 0 ? `${countdown}s` : '发送验证码' }}
            </el-button>
          </template>
        </el-input>
      </el-form-item>
    </el-form>

    <template #footer>
      <el-button @click="handleCancel">取消</el-button>
      <el-button
        type="primary"
        :loading="logging"
        @click="handleLogin"
      >
        登录
      </el-button>
    </template>
  </el-dialog>
</template>

<script setup>
import { ref, reactive } from 'vue';
import { ElMessage } from 'element-plus';
import { Phone, Key } from '@element-plus/icons-vue';
import { sendCode, loginByCode } from '@/api/auth';

const props = defineProps({
  modelValue: {
    type: Boolean,
    default: false,
  },
});

const emit = defineEmits(['update:modelValue', 'success']);

const dialogVisible = ref(props.modelValue);
const formRef = ref(null);
const sending = ref(false);
const logging = ref(false);
const countdown = ref(0);
let timer = null;

const form = reactive({
  phone: '',
  code: '',
});

const rules = {
  phone: [
    { required: true, message: '请输入手机号', trigger: 'blur' },
    { pattern: /^1[3-9]\d{9}$/, message: '手机号格式不正确', trigger: 'blur' },
  ],
  code: [
    { required: true, message: '请输入验证码', trigger: 'blur' },
    { pattern: /^\d{6}$/, message: '验证码格式不正确', trigger: 'blur' },
  ],
};

// 发送验证码
const handleSendCode = async () => {
  try {
    await formRef.value.validateField('phone');
    
    sending.value = true;
    const res = await sendCode(form.phone);

    if (res.success) {
      ElMessage.success('验证码已发送');
      startCountdown();
    } else {
      ElMessage.error(res.message || '发送失败');
    }
  } catch (error) {
    if (error !== false) {
      ElMessage.error('发送失败');
    }
  } finally {
    sending.value = false;
  }
};

// 开始倒计时
const startCountdown = () => {
  countdown.value = 60;
  timer = setInterval(() => {
    countdown.value--;
    if (countdown.value <= 0) {
      clearInterval(timer);
    }
  }, 1000);
};

// 登录
const handleLogin = async () => {
  try {
    await formRef.value.validate();
    
    logging.value = true;
    const res = await loginByCode(form.phone, form.code);

    if (res.success) {
      ElMessage.success('登录成功');
      
      // 保存Token
      localStorage.setItem('token', res.data.token);
      localStorage.setItem('user', JSON.stringify(res.data.user));
      
      emit('success', res.data.user);
      dialogVisible.value = false;
    } else {
      ElMessage.error(res.message || '登录失败');
    }
  } catch (error) {
    if (error !== false) {
      ElMessage.error('登录失败');
    }
  } finally {
    logging.value = false;
  }
};

// 取消
const handleCancel = () => {
  dialogVisible.value = false;
  form.phone = '';
  form.code = '';
};

watch(
  () => props.modelValue,
  (val) => {
    dialogVisible.value = val;
  }
);

watch(dialogVisible, (val) => {
  emit('update:modelValue', val);
  
  if (!val && timer) {
    clearInterval(timer);
    countdown.value = 0;
  }
});
</script>
```

### 3. 在主页面中使用

修改 `src/App.vue` 或相关页面：

```vue
<template>
  <div>
    <el-button @click="showLoginDialog = true">登录</el-button>
    
    <LoginDialog
      v-model="showLoginDialog"
      @success="handleLoginSuccess"
    />
  </div>
</template>

<script setup>
import { ref } from 'vue';
import LoginDialog from '@/components/LoginDialog.vue';

const showLoginDialog = ref(false);

const handleLoginSuccess = (user) => {
  console.log('登录成功:', user);
  // 更新用户状态
};
</script>
```

---

## 六、安全措施

### 1. 防止短信轰炸

```javascript
// 已实现：发送频率限制
// 已实现：发送次数限制
// 已实现：IP限流
```

### 2. 验证码安全

```javascript
// 已实现：验证码过期时间
// 已实现：验证码一次性使用
// 已实现：定期清理过期验证码
```

### 3. Token安全

```javascript
// 已实现：JWT Token
// 已实现：Token过期时间（7天）
// 建议实现：Token刷新机制
// 建议实现：HTTPS传输
```

### 4. 日志记录

```javascript
// 建议实现：记录所有登录行为
// 建议实现：记录异常登录（IP、设备等）
// 建议实现：登录失败次数过多时锁定
```

---

## 七、其他短信服务商接入

### 腾讯云短信

**安装依赖：**
```bash
npm install tencentcloud-sdk-nodejs
```

**发送短信代码：**
```javascript
const tencentcloud = require('tencentcloud-sdk-nodejs');
const SmsClient = tencentcloud.sms.v20210111.Client;

const clientConfig = {
  credential: {
    secretId: process.env.TENCENT_SECRET_ID,
    secretKey: process.env.TENCENT_SECRET_KEY,
  },
  region: 'ap-guangzhou',
  profile: {
    httpProfile: { endpoint: 'sms.tencentcloudapi.com' },
  },
};

const client = new SmsClient(clientConfig);

const params = {
  PhoneNumberSet: [`+86${phone}`],
  TemplateId: process.env.TENCENT_TEMPLATE_ID,
  TemplateParamSet: [code],
  SmsSdkAppId: process.env.TENCENT_APP_ID,
  SignName: process.env.TENCENT_SIGN_NAME,
};

await client.SendSms(params);
```

### 容联云通讯

**安装依赖：**
```bash
npm install ccplib
```

**发送短信代码：**
```javascript
const CCPRestSDK = require('ccplib');

const rest = new CCPRestSDK();
rest.init(
  'app.cloopen.com',
  '8883',
  process.env.RONGYUN_ACCOUNT_SID,
  process.env.RONGYUN_ACCOUNT_TOKEN
);

const result = await rest.sendTemplateSMS(
  phone,
  [code, '5'], // 验证码和有效期
  process.env.RONGYUN_TEMPLATE_ID
);
```

---

## 八、注意事项

### 1. 生产环境优化

#### 使用Redis存储验证码
```javascript
// 推荐使用Redis替代内存存储
const redis = require('redis');
const client = redis.createClient();

// 存储
await client.setex(`sms:${phone}`, 300, code);
await client.incr(`sms:count:${phone}`);
await client.expire(`sms:count:${phone}`, 3600);

// 验证
const code = await client.get(`sms:${phone}`);
```

#### 异步发送短信
```javascript
// 使用消息队列异步发送
const queue = require('bull');
const smsQueue = new queue('sms');

smsQueue.process(async (job) => {
  await sendSMS(job.data.phone, job.data.code);
});
```

### 2. 测试环境

使用虚拟号码或测试模式
```javascript
if (process.env.NODE_ENV === 'development') {
  // 测试环境直接返回验证码，不发送短信
  console.log('验证码:', code);
  return { success: true };
}
```

### 3. 监控告警

```javascript
// 监控短信发送成功率
// 监控短信发送量
// 监控异常发送行为
// 设置告警阈值
```

---

## 九、常见问题

### Q1: 短信发送失败怎么办？
A: 
1. 检查AccessKey是否正确
2. 检查签名和模板是否通过审核
3. 检查余额是否充足
4. 查看错误码文档

### Q2: 如何降低短信成本？
A: 
1. 使用批量短信（营销类）
2. 优化验证码逻辑，减少重复发送
3. 对比不同服务商价格
4. 使用短信群发功能

### Q3: 验证码多久过期？
A: 建议5分钟，可以修改环境变量 `SMS_CODE_EXPIRE_TIME`。

### Q4: 如何防止短信轰炸？
A: 
1. 限制发送频率（1分钟1条）
2. 限制发送次数（1小时5条）
3. 使用图形验证码
4. IP限流

### Q5: Token过期后如何处理？
A: 
1. 实现Token刷新机制
2. 使用Refresh Token
3. 自动重新登录
4. 提示用户重新登录

---

## 十、参考资源

- [阿里云短信API文档](https://help.aliyun.com/document_detail/101414.html)
- [腾讯云短信API文档](https://cloud.tencent.com/document/product/382/43194)
- [Express Rate Limit](https://github.com/nfriedly/express-rate-limit)
- [JWT最佳实践](https://jwt.io/introduction)

---

**最后更新时间**：2026年1月28日
**适用范围**：中国大陆地区
